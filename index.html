<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formula Evaluator Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 15px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        @media (min-width: 768px) {
            body {
                margin: 40px auto;
                padding: 20px;
            }
            
            .container {
                padding: 30px;
            }
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        @media (min-width: 768px) {
            h1 {
                margin-bottom: 30px;
                font-size: 2rem;
            }
        }
        
        .github-link {
            text-align: center;
            margin-bottom: 15px;
        }
        
        @media (min-width: 768px) {
            .github-link {
                margin-bottom: 20px;
            }
        }
        
        .github-link a {
            color: #007bff;
            text-decoration: none;
            font-weight: 500;
        }
        
        .github-link a:hover {
            text-decoration: underline;
        }
        
        .formula-section {
            margin-bottom: 25px;
        }
        
        .formula-input-container {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .formula-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            min-height: 48px;
            resize: none;
            overflow: hidden;
            line-height: 1.4;
            transition: height 0.2s ease;
        }
        
        .formula-input:focus {
            outline: none;
            border-color: #007bff;
        }
        
        @media (max-width: 767px) {
            .formula-input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 10px;
            }
        }
        
        .validation-icon {
            width: 24px;
            height: 24px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 12px;
            flex-shrink: 0;
        }
        
        .valid {
            color: #28a745;
        }
        
        .invalid {
            color: #dc3545;
        }
        
        .formula-help {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        
        .variables-section {
            margin-bottom: 25px;
            display: none;
        }
        
        .variables-section.show {
            display: block;
        }
        
        .variable-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        @media (min-width: 480px) {
            .variable-input-group {
                flex-direction: row;
                align-items: center;
                gap: 10px;
            }
        }
        
        .variable-label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        
        @media (min-width: 480px) {
            .variable-label {
                min-width: 100px;
                font-size: 16px;
            }
        }
        
        .variable-input {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            min-height: 44px;
        }
        
        .variable-input:focus {
            outline: none;
            border-color: #007bff;
        }
        
        .result-section {
            margin-top: 25px;
            display: none;
        }
        
        .result-section.show {
            display: block;
        }
        
        .result-label {
            font-size: 18px;
            font-weight: bold;
            padding: 15px;
            background-color: #e8f4fd;
            border: 2px solid #007bff;
            border-radius: 6px;
            color: #0056b3;
            text-align: center;
        }
        
        .error-message {
            color: #dc3545;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .examples {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        @media (min-width: 768px) {
            .examples {
                padding: 20px;
            }
        }
        
        .examples h3 {
            margin-top: 0;
            color: #555;
            font-size: 1rem;
        }
        
        @media (min-width: 768px) {
            .examples h3 {
                font-size: 1.125rem;
            }
        }
        
        .example-formula {
            font-family: 'Courier New', monospace;
            background-color: #e9ecef;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            margin: 3px;
            font-size: 14px;
            line-height: 1.2;
            word-break: break-all;
            max-width: 100%;
        }
        
        @media (min-width: 480px) {
            .example-formula {
                padding: 4px 8px;
                margin: 2px;
                font-size: 13px;
                word-break: normal;
            }
        }
        
        .example-formula:hover {
            background-color: #dee2e6;
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üßÆ Formula Evaluator Demo</h1>
        
        <div class="github-link">
            <a href="https://github.com/sgagnonboncode/equations-parsing" target="_blank">
                üìÅ View Source Code on GitHub
            </a>
        </div>
        
        <div class="formula-section">
            <div class="formula-input-container">
                <textarea id="formulaInput" 
                       class="formula-input" 
                       placeholder="Enter a formula (e.g., a + b * c, sqrt(a) + b, (x + y) * z)"
                       autocomplete="off"
                       rows="1"></textarea>
                <div id="validationIcon" class="validation-icon"></div>
            </div>
            <div class="formula-help">
                Supported operations: +, -, *, /, ^ (power), sqrt(expression)<br>
                Variables: use letters and underscores (a, b, temp_celsius, etc.)
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>
        
        <div id="variablesSection" class="variables-section">
            <h3>üìù Variable Values</h3>
            <div id="variableInputs"></div>
        </div>
        
        <div id="resultSection" class="result-section">
            <h3>üìä Result</h3>
            <div id="resultLabel" class="result-label"></div>
        </div>
        
        <div class="examples">
            <h3>üí° Try these examples:</h3>
            <span class="example-formula" onclick="setFormula('a + b')">a + b</span>
            <span class="example-formula" onclick="setFormula('(a + b) * c')">( a + b ) * c</span>
            <span class="example-formula" onclick="setFormula('sqrt(a) + b')">sqrt(a) + b</span>
            <span class="example-formula" onclick="setFormula('a ^ b + c')">a ^ b + c</span>
            <span class="example-formula" onclick="setFormula('(Temperature_fahrenheit - 32) * 5/9')">(Temperature_fahrenheit - 32) * 5/9</span>
            <span class="example-formula" onclick="setFormula('sqrt(sqrt(a + b))')">sqrt(sqrt(a + b))</span>
            <span class="example-formula" onclick="setFormula('alpha * beta_gamma + sqrt(delta)')">alpha * beta_gamma + sqrt(delta)</span>
        </div>
        
        <div class="footer">
            <p>üöÄ TypeScript Formula Evaluator | Built with Claude Sonnet 4 |
            <a href="https://github.com/sgagnonboncode/equations-parsing" target="_blank">GitHub Repository</a>
            </p>
        </div>
    </div>

    <!-- Include a browser-compatible version -->
    <script>
        // Manually include the core formula evaluation logic for browser compatibility
        
        class FormulaEvaluator {
            static OPERATORS = ['+', '-', '*', '/', '(', ')', '^', 'sqrt'];
            static PRECEDENCE = {
                '+': 1,
                '-': 1,
                '*': 2,
                '/': 2,
                '^': 3,
                'sqrt': 4
            };

            static extractVariables(formula) {
                const variables = new Set();
                let i = 0;
                
                while (i < formula.length) {
                    if (/[a-zA-Z]/.test(formula[i])) {
                        let variable = '';
                        while (i < formula.length && /[a-zA-Z_]/.test(formula[i])) {
                            variable += formula[i];
                            i++;
                        }
                        if (variable !== 'sqrt') {
                            variables.add(variable);
                        }
                    } else {
                        i++;
                    }
                }
                
                return Array.from(variables).sort();
            }

            static tokenize(formula) {
                const tokens = [];
                let i = 0;
                
                while (i < formula.length) {
                    if (formula[i] === ' ') {
                        i++;
                        continue;
                    }
                    
                    if (/\d/.test(formula[i])) {
                        let number = '';
                        while (i < formula.length && (/\d/.test(formula[i]) || formula[i] === '.')) {
                            number += formula[i];
                            i++;
                        }
                        tokens.push(number);
                    }
                    else if (/[a-zA-Z]/.test(formula[i])) {
                        let variable = '';
                        while (i < formula.length && /[a-zA-Z_]/.test(formula[i])) {
                            variable += formula[i];
                            i++;
                        }
                        tokens.push(variable);
                    }
                    else if (this.OPERATORS.includes(formula[i])) {
                        tokens.push(formula[i]);
                        i++;
                    }
                    else {
                        throw new Error(`Invalid character in formula: ${formula[i]}`);
                    }
                }
                
                return tokens;
            }

            static toPostfix(tokens) {
                const output = [];
                const operators = [];

                for (const token of tokens) {
                    if (/^\d+\.?\d*$/.test(token) || (/^[a-zA-Z_]+$/.test(token) && token !== 'sqrt')) {
                        output.push(token);
                    }
                    else if (token === 'sqrt') {
                        operators.push(token);
                    }
                    else if (token === '(') {
                        operators.push(token);
                    }
                    else if (token === ')') {
                        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
                            output.push(operators.pop());
                        }
                        if (operators.length === 0) {
                            throw new Error('Mismatched parentheses');
                        }
                        operators.pop();
                    }
                    else if (token in this.PRECEDENCE) {
                        if (token === 'sqrt') {
                            operators.push(token);
                        } else {
                            while (
                                operators.length > 0 &&
                                operators[operators.length - 1] !== '(' &&
                                this.PRECEDENCE[operators[operators.length - 1]] >= this.PRECEDENCE[token]
                            ) {
                                output.push(operators.pop());
                            }
                            operators.push(token);
                        }
                    }
                    else {
                        throw new Error(`Unknown token: ${token}`);
                    }
                }

                while (operators.length > 0) {
                    const op = operators.pop();
                    if (op === '(' || op === ')') {
                        throw new Error('Mismatched parentheses');
                    }
                    output.push(op);
                }

                return output;
            }

            static evaluatePostfix(postfix, variables) {
                const stack = [];

                for (const token of postfix) {
                    if (/^\d+\.?\d*$/.test(token)) {
                        stack.push(parseFloat(token));
                    }
                    else if (/^[a-zA-Z_]+$/.test(token) && token !== 'sqrt') {
                        if (!(token in variables)) {
                            throw new Error(`Variable '${token}' not provided`);
                        }
                        stack.push(variables[token]);
                    }
                    else if (token in this.PRECEDENCE) {
                        if (token === 'sqrt') {
                            if (stack.length < 1) {
                                throw new Error(`Insufficient operands for sqrt function`);
                            }
                            const a = stack.pop();
                            if (a < 0) {
                                throw new Error('Cannot take square root of negative number');
                            }
                            stack.push(Math.sqrt(a));
                        } else {
                            if (stack.length < 2) {
                                throw new Error(`Insufficient operands for operator '${token}'`);
                            }
                            const b = stack.pop();
                            const a = stack.pop();
                            
                            switch (token) {
                                case '+':
                                    stack.push(a + b);
                                    break;
                                case '-':
                                    stack.push(a - b);
                                    break;
                                case '*':
                                    stack.push(a * b);
                                    break;
                                case '/':
                                    if (b === 0) {
                                        throw new Error('Division by zero');
                                    }
                                    stack.push(a / b);
                                    break;
                                case '^':
                                    stack.push(Math.pow(a, b));
                                    break;
                                default:
                                    throw new Error(`Unknown operator: ${token}`);
                            }
                        }
                    }
                    else {
                        throw new Error(`Unknown token in postfix: ${token}`);
                    }
                }

                if (stack.length !== 1) {
                    throw new Error('Invalid expression');
                }

                return stack[0];
            }

            static evaluate(formula, values) {
                try {
                    const variables = this.extractVariables(formula);
                    
                    if (variables.length !== values.length) {
                        throw new Error(
                            `Expected ${variables.length} values for variables [${variables.join(', ')}], but got ${values.length}`
                        );
                    }

                    const assignment = {};
                    variables.forEach((variable, index) => {
                        assignment[variable] = values[index];
                    });

                    const tokens = this.tokenize(formula);
                    const postfix = this.toPostfix(tokens);
                    const result = this.evaluatePostfix(postfix, assignment);

                    return {
                        result,
                        variables
                    };
                } catch (error) {
                    throw new Error(`Formula evaluation failed: ${error.message}`);
                }
            }

            static getVariables(formula) {
                return this.extractVariables(formula);
            }

            static validateFormula(formula) {
                try {
                    if (!formula || formula.trim().length === 0) {
                        return false;
                    }

                    this.extractVariables(formula);
                    
                    const tokens = this.tokenize(formula);
                    
                    if (tokens.length === 0) {
                        return false;
                    }
                    
                    for (let i = 0; i < tokens.length; i++) {
                        const token = tokens[i];
                        const prevToken = i > 0 ? tokens[i - 1] : null;
                        const nextToken = i < tokens.length - 1 ? tokens[i + 1] : null;
                        
                        if (['+', '-', '*', '/', '^'].includes(token)) {
                            if (i === 0) return false;
                            if (i === tokens.length - 1) return false;
                            if (prevToken && ['+', '-', '*', '/', '^'].includes(prevToken)) return false;
                        }
                        
                        if (token === '(') {
                            if (prevToken && /^[a-zA-Z_0-9.]+$/.test(prevToken) && prevToken !== 'sqrt') {
                                return false;
                            }
                        }
                        
                        if (token === 'sqrt') {
                            if (!nextToken || nextToken !== '(') return false;
                            if (i + 2 < tokens.length && tokens[i + 2] === ')') return false;
                        }
                    }
                    
                    this.toPostfix(tokens);
                    
                    return true;
                } catch (error) {
                    return false;
                }
            }
        }

        // Expose functions globally
        window.evaluateFormula = function(formula, values) {
            return FormulaEvaluator.evaluate(formula, values).result;
        };

        window.getFormulaVariables = function(formula) {
            return FormulaEvaluator.getVariables(formula);
        };

        window.validateFormula = function(formula) {
            return FormulaEvaluator.validateFormula(formula);
        };
    </script>
    
    <script>
        // Get references to DOM elements
        const formulaInput = document.getElementById('formulaInput');
        const validationIcon = document.getElementById('validationIcon');
        const errorMessage = document.getElementById('errorMessage');
        const variablesSection = document.getElementById('variablesSection');
        const variableInputs = document.getElementById('variableInputs');
        const resultSection = document.getElementById('resultSection');
        const resultLabel = document.getElementById('resultLabel');
        
        let currentVariables = [];
        let variableElements = {};
        
        // Function to auto-expand textarea
        function autoExpandTextarea(textarea) {
            textarea.style.height = 'auto';
            const newHeight = Math.max(48, textarea.scrollHeight);
            textarea.style.height = newHeight + 'px';
        }
        
        // Function to validate formula and update UI
        function validateFormulaUI() {
            const formula = formulaInput.value.trim();
            errorMessage.textContent = '';
            
            // Auto-expand the textarea
            autoExpandTextarea(formulaInput);
            
            if (!formula) {
                validationIcon.textContent = '';
                hideVariablesAndResult();
                return;
            }
            
            try {
                // Validate the formula
                const isValid = window.validateFormula(formula);
                
                if (isValid) {
                    validationIcon.textContent = '‚úì';
                    validationIcon.className = 'validation-icon valid';
                    
                    // Extract variables
                    const variables = window.getFormulaVariables(formula);
                    updateVariableInputs(variables);
                } else {
                    validationIcon.textContent = '‚úó';
                    validationIcon.className = 'validation-icon invalid';
                    errorMessage.textContent = 'Invalid formula syntax';
                    hideVariablesAndResult();
                }
            } catch (error) {
                validationIcon.textContent = '‚úó';
                validationIcon.className = 'validation-icon invalid';
                errorMessage.textContent = 'Error: ' + error.message;
                hideVariablesAndResult();
            }
        }
        
        // Function to update variable inputs
        function updateVariableInputs(variables) {
            currentVariables = variables;
            variableInputs.innerHTML = '';
            variableElements = {};
            
            if (variables.length === 0) {
                // No variables, just show result
                variablesSection.classList.remove('show');
                calculateResult();
            } else {
                // Create input for each variable
                variables.forEach(variable => {
                    const group = document.createElement('div');
                    group.className = 'variable-input-group';
                    
                    const label = document.createElement('label');
                    label.className = 'variable-label';
                    label.textContent = variable + ':';
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.step = 'any';
                    input.className = 'variable-input';
                    input.placeholder = 'Enter value for ' + variable;
                    input.addEventListener('input', calculateResult);
                    
                    group.appendChild(label);
                    group.appendChild(input);
                    variableInputs.appendChild(group);
                    
                    variableElements[variable] = input;
                });
                
                variablesSection.classList.add('show');
                calculateResult();
            }
        }
        
        // Function to calculate and display result
        function calculateResult() {
            if (currentVariables.length === 0) {
                // No variables, evaluate directly
                const formula = formulaInput.value.trim();
                try {
                    const result = window.evaluateFormula(formula, []);
                    resultLabel.textContent = `Result: ${result}`;
                    resultSection.classList.add('show');
                } catch (error) {
                    resultSection.classList.remove('show');
                }
                return;
            }
            
            // Check if all variables have values
            const values = [];
            let allFilled = true;
            
            currentVariables.forEach(variable => {
                const input = variableElements[variable];
                const value = parseFloat(input.value);
                
                if (isNaN(value) || input.value.trim() === '') {
                    allFilled = false;
                } else {
                    values.push(value);
                }
            });
            
            if (allFilled) {
                try {
                    const formula = formulaInput.value.trim();
                    const result = window.evaluateFormula(formula, values);
                    resultLabel.textContent = `Result: ${result}`;
                    resultSection.classList.add('show');
                } catch (error) {
                    resultLabel.textContent = `Error: ${error.message}`;
                    resultSection.classList.add('show');
                }
            } else {
                resultSection.classList.remove('show');
            }
        }
        
        // Function to hide variables and result sections
        function hideVariablesAndResult() {
            variablesSection.classList.remove('show');
            resultSection.classList.remove('show');
        }
        
        // Function to set formula (used by examples)
        function setFormula(formula) {
            formulaInput.value = formula;
            validateFormulaUI();
        }
        
        // Add event listener for formula input
        formulaInput.addEventListener('input', validateFormulaUI);
        formulaInput.addEventListener('paste', function() {
            // Handle paste events with a slight delay to ensure content is pasted
            setTimeout(validateFormulaUI, 10);
        });
        
        // Initialize
        validateFormulaUI();
    </script>
</body>
</html>